{"version":3,"file":"35.6ecd5f1253d938653cf6.bundle.js","sources":["webpack:///../superset-ui-legacy-plugin-chart-table/src/Table.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable sort-keys, no-magic-numbers, complexity, func-names */\n/* eslint-disable babel/no-invalid-this, babel/new-cap, no-negated-condition */\n/* eslint-disable prefer-destructuring, react/forbid-prop-types */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport dt from 'datatables.net-bs/js/dataTables.bootstrap';\nimport dompurify from 'dompurify';\nimport { getNumberFormatter, NumberFormats } from '@superset-ui/number-format';\nimport { getTimeFormatter } from '@superset-ui/time-format';\nimport fixTableHeight from './utils/fixTableHeight';\nimport 'datatables.net-bs/css/dataTables.bootstrap.css';\nimport './Table.css';\n\nconst $ = dt.$;\n\nconst propTypes = {\n  // Each object is { field1: value1, field2: value2 }\n  data: PropTypes.arrayOf(PropTypes.object),\n  height: PropTypes.number,\n  alignPositiveNegative: PropTypes.bool,\n  colorPositiveNegative: PropTypes.bool,\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      key: PropTypes.string,\n      label: PropTypes.string,\n      format: PropTypes.string,\n    }),\n  ),\n  filters: PropTypes.object,\n  includeSearch: PropTypes.bool,\n  metrics: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.object])),\n  onAddFilter: PropTypes.func,\n  onRemoveFilter: PropTypes.func,\n  orderDesc: PropTypes.bool,\n  pageLength: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  percentMetrics: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.object])),\n  tableFilter: PropTypes.bool,\n  tableTimestampFormat: PropTypes.string,\n  timeseriesLimitMetric: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n};\n\nconst formatValue = getNumberFormatter(NumberFormats.INTEGER);\nconst formatPercent = getNumberFormatter(NumberFormats.PERCENT_3_POINT);\nfunction NOOP() {}\n\nfunction TableVis(element, props) {\n  const {\n    data,\n    height,\n    alignPositiveNegative = false,\n    colorPositiveNegative = false,\n    columns,\n    filters = {},\n    includeSearch = false,\n    metrics: rawMetrics,\n    onAddFilter = NOOP,\n    onRemoveFilter = NOOP,\n    orderDesc,\n    pageLength,\n    percentMetrics,\n    tableFilter,\n    tableTimestampFormat,\n    timeseriesLimitMetric,\n  } = props;\n\n  const $container = $(element);\n  $container.addClass('superset-legacy-chart-table');\n\n  const metrics = (rawMetrics || [])\n    .map(m => m.label || m)\n    // Add percent metrics\n    .concat((percentMetrics || []).map(m => `%${m}`))\n    // Removing metrics (aggregates) that are strings\n    .filter(m => typeof data[0][m] === 'number');\n\n  function col(c) {\n    const arr = [];\n    for (let i = 0; i < data.length; i += 1) {\n      arr.push(data[i][c]);\n    }\n\n    return arr;\n  }\n  const maxes = {};\n  const mins = {};\n  for (let i = 0; i < metrics.length; i += 1) {\n    if (alignPositiveNegative) {\n      maxes[metrics[i]] = d3.max(col(metrics[i]).map(Math.abs));\n    } else {\n      maxes[metrics[i]] = d3.max(col(metrics[i]));\n      mins[metrics[i]] = d3.min(col(metrics[i]));\n    }\n  }\n\n  const tsFormatter = getTimeFormatter(tableTimestampFormat);\n\n  const div = d3.select(element);\n  div.html('');\n  const table = div\n    .append('table')\n    .classed(\n      'dataframe dataframe table table-striped ' +\n        'table-condensed table-hover dataTable no-footer',\n      true,\n    )\n    .attr('width', '100%');\n\n  table\n    .append('thead')\n    .append('tr')\n    .selectAll('th')\n    .data(columns.map(c => c.label))\n    .enter()\n    .append('th')\n    .text(d => d);\n\n  table\n    .append('tbody')\n    .selectAll('tr')\n    .data(data)\n    .enter()\n    .append('tr')\n    .selectAll('td')\n    .data(row =>\n      columns.map(({ key, format }) => {\n        const val = row[key];\n        let html;\n        const isMetric = metrics.indexOf(key) >= 0;\n        if (key === '__timestamp') {\n          html = tsFormatter(val);\n        }\n        if (typeof val === 'string') {\n          html = `<span class=\"like-pre\">${dompurify.sanitize(val)}</span>`;\n        }\n        if (isMetric) {\n          html = getNumberFormatter(format)(val);\n        }\n        if (key[0] === '%') {\n          html = formatPercent(val);\n        }\n\n        return {\n          col: key,\n          val,\n          html,\n          isMetric,\n        };\n      }),\n    )\n    .enter()\n    .append('td')\n    .style('background-image', d => {\n      if (d.isMetric) {\n        const r = colorPositiveNegative && d.val < 0 ? 150 : 0;\n        if (alignPositiveNegative) {\n          const perc = Math.abs(Math.round((d.val / maxes[d.col]) * 100));\n\n          // The 0.01 to 0.001 is a workaround for what appears to be a\n          // CSS rendering bug on flat, transparent colors\n          return (\n            `linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`\n          );\n        }\n        const posExtent = Math.abs(Math.max(maxes[d.col], 0));\n        const negExtent = Math.abs(Math.min(mins[d.col], 0));\n        const tot = posExtent + negExtent;\n        const perc1 = Math.round((Math.min(negExtent + d.val, negExtent) / tot) * 100);\n        const perc2 = Math.round((Math.abs(d.val) / tot) * 100);\n\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (\n          `linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n          `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n          `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`\n        );\n      }\n\n      return null;\n    })\n    .classed('text-right', d => d.isMetric)\n    .attr('title', d => {\n      if (typeof d.val === 'string') {\n        return d.val;\n      }\n      if (!Number.isNaN(d.val)) {\n        return formatValue(d.val);\n      }\n\n      return null;\n    })\n    .attr('data-sort', d => (d.isMetric ? d.val : null))\n    // Check if the dashboard currently has a filter for each row\n    .classed('filtered', d => filters && filters[d.col] && filters[d.col].indexOf(d.val) >= 0)\n    .on('click', function(d) {\n      if (!d.isMetric && tableFilter) {\n        const td = d3.select(this);\n        if (td.classed('filtered')) {\n          onRemoveFilter(d.col, [d.val]);\n          d3.select(this).classed('filtered', false);\n        } else {\n          d3.select(this).classed('filtered', true);\n          onAddFilter(d.col, [d.val]);\n        }\n      }\n    })\n    .style('cursor', d => (!d.isMetric ? 'pointer' : ''))\n    .html(d => (d.html ? d.html : d.val));\n\n  const paging = pageLength && pageLength > 0;\n\n  const datatable = $container.find('.dataTable').DataTable({\n    paging,\n    pageLength,\n    aaSorting: [],\n    searching: includeSearch,\n    bInfo: false,\n    scrollY: `${height}px`,\n    scrollCollapse: true,\n    scrollX: true,\n  });\n\n  fixTableHeight($container.find('.dataTables_wrapper'), height);\n  // Sorting table by main column\n  let sortBy;\n  const limitMetric = Array.isArray(timeseriesLimitMetric)\n    ? timeseriesLimitMetric[0]\n    : timeseriesLimitMetric;\n  if (limitMetric) {\n    // Sort by as specified\n    sortBy = limitMetric.label || limitMetric;\n  } else if (metrics.length > 0) {\n    // If not specified, use the first metric from the list\n    sortBy = metrics[0];\n  }\n  if (sortBy) {\n    const keys = columns.map(c => c.key);\n    const index = keys.indexOf(sortBy);\n    datatable.column(index).order(orderDesc ? 'desc' : 'asc');\n    if (metrics.indexOf(sortBy) < 0) {\n      // Hiding the sortBy column if not in the metrics list\n      datatable.column(index).visible(false);\n    }\n  }\n  datatable.draw();\n}\n\nTableVis.displayName = 'TableVis';\nTableVis.propTypes = propTypes;\n\nexport default TableVis;\n"],"mappings":"AA+BA","sourceRoot":""}